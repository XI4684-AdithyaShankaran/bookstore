name: Secrets Management

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to update secrets for"
        required: true
        default: "local"
        type: choice
        options:
          - local
          - dev
          - prod
      action:
        description: "Action to perform"
        required: true
        default: "validate"
        type: choice
        options:
          - validate
          - update
          - rotate

jobs:
  secrets-management:
    runs-on: ubuntu-latest
    # Use a default environment or handle dynamically
    environment: ${{ github.event.inputs.environment == 'prod' && 'production' || github.event.inputs.environment == 'dev' && 'development' || 'local' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Setting up ${{ github.event.inputs.environment }} environment"
          # Handle different environment file names
          if [ "${{ github.event.inputs.environment }}" = "dev" ]; then
            cp env.development .env
          elif [ "${{ github.event.inputs.environment }}" = "prod" ]; then
            cp env.production .env
          else
            cp env.${{ github.event.inputs.environment }} .env
          fi
          echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV

      - name: Validate secrets
        if: github.event.inputs.action == 'validate'
        run: |
          echo "Validating secrets for ${{ github.event.inputs.environment }} environment"

          # Check required environment variables
          required_vars=(
            "DATABASE_URL"
            "SECRET_KEY"
            "NEXTAUTH_SECRET"
          )

          for var in "${required_vars[@]}"; do
            if grep -q "^${var}=" .env; then
              echo "✅ $var is configured"
            else
              echo "❌ $var is missing"
              exit 1
            fi
          done

          echo "✅ All required secrets are configured"

      - name: Update Kubernetes secrets
        if: github.event.inputs.action == 'update'
        run: |
          echo "Updating Kubernetes secrets for ${{ github.event.inputs.environment }} environment"

          # Create namespace if it doesn't exist
          kubectl create namespace bookstore-${{ github.event.inputs.environment }} --dry-run=client -o yaml | kubectl apply -f -

          # Create secret from .env file
          kubectl create secret generic bookstore-secrets-${{ github.event.inputs.environment }} \
            --from-file=.env \
            --namespace=bookstore-${{ github.event.inputs.environment }} \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "✅ Kubernetes secrets updated"

      - name: Rotate secrets
        if: github.event.inputs.action == 'rotate'
        run: |
          echo "Rotating secrets for ${{ github.event.inputs.environment }} environment"

          # Generate new secrets
          NEW_SECRET_KEY=$(openssl rand -base64 32)
          NEW_NEXTAUTH_SECRET=$(openssl rand -base64 32)

          # Update .env file with new secrets
          sed -i "s/SECRET_KEY=.*/SECRET_KEY=$NEW_SECRET_KEY/" .env
          sed -i "s/NEXTAUTH_SECRET=.*/NEXTAUTH_SECRET=$NEW_NEXTAUTH_SECRET/" .env

          # Update Kubernetes secrets
          kubectl create secret generic bookstore-secrets-${{ github.event.inputs.environment }} \
            --from-file=.env \
            --namespace=bookstore-${{ github.event.inputs.environment }} \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "✅ Secrets rotated successfully"

      - name: Create GitHub secrets
        if: github.event.inputs.action == 'update'
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ github.event.inputs.environment }}';
            const envFile = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: `env.${environment}`
            });

            const envContent = Buffer.from(envFile.data.content, 'base64').toString();

            // Parse environment variables
            const secrets = {};
            envContent.split('\n').forEach(line => {
              const [key, value] = line.split('=');
              if (key && value && !key.startsWith('#')) {
                secrets[key.trim()] = value.trim();
              }
            });

            // Create GitHub secrets for the environment
            for (const [key, value] of Object.entries(secrets)) {
              try {
                await github.rest.actions.createRepoSecret({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  secret_name: `${environment.toUpperCase()}_${key}`,
                  encrypted_value: value
                });
                console.log(`✅ Created secret: ${environment.toUpperCase()}_${key}`);
              } catch (error) {
                console.log(`⚠️ Secret ${environment.toUpperCase()}_${key} already exists`);
              }
            }
